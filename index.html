<!DOCTYPE html>
<html>
<head>
  <meta name="viewport" content="width=device-width,initial-scale=1.0">
  <title>Infinity Scroll Videos</title>
  <style>
    body, html {
      margin: 0;
      padding: 0;
      overflow: hidden;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      background-color: #000;
    }

    #video-container {
      width: 100%;
      height: 100%;
      position: relative;
      display: flex;
      flex-direction: column;
      overflow-y: auto;
      scroll-snap-type: y mandatory;
    }

    #video-container::-webkit-scrollbar {
      display: none;  /* Safari and Chrome */
    }

    .video-item {
      width: 100%;
      height: 100%;
      flex-shrink: 0;
      scroll-snap-align: start;
      position: relative;
    }

    video {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }
  </style>
</head>
<body>
  <div id="video-container"></div>
  <script src="/socket.io/socket.io.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io-stream/0.9.1/socket.io-stream.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/hammer.js/2.0.8/hammer.min.js"></script>
  <script>
    const socket = io();
    const ss = socketioStream;

    const videos = [
      { id: 0, src: 'vid/A0.mp4' },
      { id: 1, src: 'vid/A1.mp4' },
      { id: 2, src: 'vid/A2.mp4' },
      { id: 3, src: 'vid/A3.mp4' },
      { id: 4, src: 'vid/A4.mp4' },
      { id: 5, src: 'vid/A5.mp4' },
      { id: 6, src: 'vid/A6.mp4' },
      { id: 7, src: 'vid/A7.mp4' },
      { id: 8, src: 'vid/A8.mp4' },
      { id: 9, src: 'vid/A9.mp4' },
    ];

    let currentVideoIndex = 0;
    let watchedVideos = [];
    let recentWatched = [];
    let loadedVideos = [];
    let videoCache = new Map(); // 비디오 데이터를 캐싱하기 위한 Map 객체

    const videoContainer = document.getElementById('video-container');

    function loadVideo(video, index) {
      const videoItem = document.createElement('div');
      videoItem.className = 'video-item';
      videoItem.dataset.index = video.id;

      const videoElement = document.createElement('video');
      videoElement.controls = true;

      if (videoCache.has(video.id)) {
        // 캐시에 비디오 데이터가 있는 경우
        videoElement.src = videoCache.get(video.id);
        videoElement.play();
      } else {
        // 캐시에 비디오 데이터가 없는 경우 서버로부터 스트림 요청
        const stream = ss.createStream();
        ss(socket).emit('video-request', stream, { videoId: video.id });
        const chunks = [];
        stream.on('data', (chunk) => {
          chunks.push(chunk);
        });
        stream.on('end', () => {
          const blob = new Blob(chunks, { type: 'video/webm' });
          const videoUrl = URL.createObjectURL(blob);
          videoCache.set(video.id, videoUrl); // 비디오 데이터를 캐시에 저장
          videoElement.src = videoUrl;
          videoElement.play();
        });
      }

      videoItem.appendChild(videoElement);
      videoContainer.appendChild(videoItem);
    }

    function getRandomVideo() {
      let availableVideos = videos.filter(v => !watchedVideos.includes(v.id));
      if (availableVideos.length === 0) {
        availableVideos = videos.filter(v => !recentWatched.includes(v.id));
      }
      let randomVideo = availableVideos[Math.floor(Math.random() * availableVideos.length)];
      return randomVideo;
    }

    function reportVideoWatched(video) {
      console.log(`Video ID ${video.id} watched`);
      socket.emit('video watched', { videoId: video.id });
    }

    function setupSwipeHandler() {
      const hammer = new Hammer(videoContainer);
      hammer.get('swipe').set({ direction: Hammer.DIRECTION_VERTICAL });

      hammer.on('swipeup', () => {
        currentVideoIndex++;
        const currentVideo = updateVideos();
        videoContainer.scrollTo(0, currentVideoIndex * window.innerHeight);
        reportVideoWatched(currentVideo);
      });

      hammer.on('swipedown', () => {
        if (currentVideoIndex > 0) {
          currentVideoIndex--;
          const currentVideo = updateVideos();
          videoContainer.scrollTo(0, currentVideoIndex * window.innerHeight);
          reportVideoWatched(currentVideo);
        }
      });
    }

    function updateVideos() {
      const videoItems = document.querySelectorAll('.video-item');
      if (videoItems.length > 3) {
        videoContainer.removeChild(videoItems[0]);
      }

      const newVideo = getRandomVideo();
      if (!watchedVideos.includes(newVideo.id)) {
        watchedVideos.push(newVideo.id);
      }
      recentWatched.push(newVideo.id);
      if (recentWatched.length > 5) {
        recentWatched.shift();
      }
      loadVideo(newVideo, currentVideoIndex);

      return newVideo;
    }

    document.addEventListener('DOMContentLoaded', () => {
      for (let i = 0; i < 3; i++) {
        const video = getRandomVideo();
        loadedVideos.push(video);
        loadVideo(video, i);
      }
      setupSwipeHandler();
    });
  </script>
</body>
</html>
